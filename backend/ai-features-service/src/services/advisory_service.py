"""
Automated Financial Advisory Service

Provides intelligent financial advice and recommendations:
- Personalized financial planning
- Investment recommendations
- Risk assessment and management
- Goal-based financial advice
- Market insights and analysis
- Portfolio optimization
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
import yfinance as yf

from models.advisory import (
    FinancialAdvisoryRequest,
    FinancialAdvisoryResponse,
    InvestmentRecommendation,
    RiskAssessment,
    FinancialGoal,
    PortfolioAllocation,
    MarketInsight,
    PersonalizedAdvice
)
from config.database import get_database
from config.redis_client import get_redis
from utils.risk_calculator import RiskCalculator
from utils.portfolio_optimizer import PortfolioOptimizer
from utils.market_analyzer import MarketAnalyzer

logger = logging.getLogger(__name__)


class AdvisoryService:
    """Automated financial advisory and recommendation service"""
    
    def __init__(self, model_manager):
        self.model_manager = model_manager
        self.risk_calculator = RiskCalculator()
        self.portfolio_optimizer = PortfolioOptimizer()
        self.market_analyzer = MarketAnalyzer()
        
        # Risk profiles
        self.risk_profiles = {
            'conservative': {
                'stocks': 0.3,
                'bonds': 0.6,
                'cash': 0.1,
                'risk_tolerance': 0.2
            },
            'moderate': {
                'stocks': 0.6,
                'bonds': 0.3,
                'cash': 0.1,
                'risk_tolerance': 0.5
            },
            'aggressive': {
                'stocks': 0.8,
                'bonds': 0.15,
                'cash': 0.05,
                'risk_tolerance': 0.8
            }
        }
        
        # Investment categories
        self.investment_categories = {
            'stocks': ['SPY', 'VTI', 'QQQ', 'IWM'],
            'bonds': ['BND', 'TLT', 'IEF', 'HYG'],
            'international': ['VEA', 'VWO', 'EFA'],
            'real_estate': ['VNQ', 'REIT'],
            'commodities': ['GLD', 'SLV', 'DBC'],
            'crypto': ['BTC-USD', 'ETH-USD']
        }
        
        self.is_initialized = False
        
    async def initialize(self):
        """Initialize the advisory service"""
        try:
            logger.info("Initializing Financial Advisory Service...")
            
            # Initialize components
            await self.risk_calculator.initialize()
            await self.portfolio_optimizer.initialize()
            await self.market_analyzer.initialize()
            
            # Load market data
            await self._load_market_data()
            
            self.is_initialized = True
            logger.info("Financial Advisory Service initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize Financial Advisory Service: {e}")
            raise
    
    async def get_financial_advice(
        self, 
        request: FinancialAdvisoryRequest
    ) -> FinancialAdvisoryResponse:
        """
        Generate comprehensive financial advice
        
        Args:
            request: Financial advisory request parameters
            
        Returns:
            Detailed financial advice and recommendations
        """
        if not self.is_initialized:
            raise RuntimeError("Financial Advisory Service not initialized")
        
        try:
            logger.info(f"Generating financial advice for user {request.user_id}")
            
            # Get user financial profile
            user_profile = await self._get_user_financial_profile(request.user_id)
            
            # Assess risk profile
            risk_assessment = await self._assess_risk_profile(user_profile, request)
            
            # Generate investment recommendations
            investment_recommendations = await self._generate_investment_recommendations(
                user_profile, 
                risk_assessment,
                request
            )
            
            # Create portfolio allocation
            portfolio_allocation = await self._create_portfolio_allocation(
                user_profile,
                risk_assessment,
                request.investment_amount or 0
            )
            
            # Analyze financial goals
            goal_analysis = await self._analyze_financial_goals(
                user_profile,
                request.financial_goals or []
            )
            
            # Get market insights
            market_insights = await self._get_market_insights()
            
            # Generate personalized advice
            personalized_advice = await self._generate_personalized_advice(
                user_profile,
                risk_assessment,
                investment_recommendations,
                goal_analysis
            )
            
            # Create response
            response = FinancialAdvisoryResponse(
                user_id=request.user_id,
                advice_date=datetime.now(),
                risk_assessment=risk_assessment,
                investment_recommendations=investment_recommendations,
                portfolio_allocation=portfolio_allocation,
                financial_goals_analysis=goal_analysis,
                market_insights=market_insights,
                personalized_advice=personalized_advice,
                confidence_score=await self._calculate_confidence_score(user_profile),
                next_review_date=datetime.now() + timedelta(days=90)
            )
            
            # Cache advice
            await self._cache_advice(request.user_id, response)
            
            logger.info(f"Financial advice generated for user {request.user_id}")
            return response
            
        except Exception as e:
            logger.error(f"Error generating financial advice: {e}")
            raise
    
    async def _get_user_financial_profile(self, user_id: str) -> Dict[str, Any]:
        """Get comprehensive user financial profile"""
        try:
            db = await get_database()
            
            # Get user basic info
            user_query = """
            SELECT age, income, employment_status, dependents, 
                   financial_experience, investment_knowledge
            FROM users WHERE id = %s
            """
            user_info = await db.fetch_one(user_query, [user_id])
            
            # Get transaction history
            transactions_query = """
            SELECT 
                SUM(CASE WHEN amount > 0 THEN amount ELSE 0 END) as total_income,
                SUM(CASE WHEN amount < 0 THEN ABS(amount) ELSE 0 END) as total_expenses,
                AVG(CASE WHEN amount > 0 THEN amount ELSE 0 END) as avg_income,
                AVG(CASE WHEN amount < 0 THEN ABS(amount) ELSE 0 END) as avg_expense,
                COUNT(*) as transaction_count
            FROM transactions 
            WHERE user_id = %s 
                AND created_at >= NOW() - INTERVAL '12 months'
            """
            financial_data = await db.fetch_one(transactions_query, [user_id])
            
            # Get current assets/liabilities
            assets_query = """
            SELECT 
                SUM(CASE WHEN type = 'asset' THEN value ELSE 0 END) as total_assets,
                SUM(CASE WHEN type = 'liability' THEN value ELSE 0 END) as total_liabilities
            FROM user_financial_data 
            WHERE user_id = %s
            """
            balance_sheet = await db.fetch_one(assets_query, [user_id])
            
            # Get investment history
            investments_query = """
            SELECT investment_type, SUM(amount) as total_invested,
                   AVG(return_rate) as avg_return
            FROM user_investments 
            WHERE user_id = %s
            GROUP BY investment_type
            """
            investments = await db.fetch_all(investments_query, [user_id])
            
            # Compile profile
            profile = {
                'user_info': dict(user_info) if user_info else {},
                'financial_data': dict(financial_data) if financial_data else {},
                'balance_sheet': dict(balance_sheet) if balance_sheet else {},
                'investments': [dict(inv) for inv in investments] if investments else [],
                'net_worth': (balance_sheet['total_assets'] or 0) - (balance_sheet['total_liabilities'] or 0) if balance_sheet else 0,
                'monthly_savings': ((financial_data['total_income'] or 0) - (financial_data['total_expenses'] or 0)) / 12 if financial_data else 0
            }
            
            return profile
            
        except Exception as e:
            logger.error(f"Error getting user financial profile: {e}")
            return {}
    
    async def _assess_risk_profile(
        self, 
        user_profile: Dict[str, Any], 
        request: FinancialAdvisoryRequest
    ) -> RiskAssessment:
        """Assess user's risk profile and tolerance"""
        try:
            # Calculate risk score based on multiple factors
            risk_factors = []
            
            # Age factor (younger = higher risk tolerance)
            age = user_profile.get('user_info', {}).get('age', 35)
            age_score = max(0, min(1, (65 - age) / 30))  # Normalize to 0-1
            risk_factors.append(('age', age_score, 0.2))
            
            # Income stability
            income = user_profile.get('user_info', {}).get('income', 0)
            employment_status = user_profile.get('user_info', {}).get('employment_status', 'employed')
            income_score = 0.8 if employment_status == 'employed' else 0.4
            if income > 100000:
                income_score = min(1.0, income_score + 0.2)
            risk_factors.append(('income', income_score, 0.25))
            
            # Financial cushion (emergency fund)
            monthly_expenses = user_profile.get('financial_data', {}).get('avg_expense', 0) * 30
            net_worth = user_profile.get('net_worth', 0)
            cushion_months = net_worth / max(monthly_expenses, 1)
            cushion_score = min(1.0, cushion_months / 6)  # 6 months = full score
            risk_factors.append(('cushion', cushion_score, 0.2))
            
            # Investment experience
            experience = user_profile.get('user_info', {}).get('investment_knowledge', 'beginner')
            experience_scores = {'beginner': 0.2, 'intermediate': 0.6, 'advanced': 1.0}
            experience_score = experience_scores.get(experience, 0.2)
            risk_factors.append(('experience', experience_score, 0.15))
            
            # Dependents (more dependents = lower risk tolerance)
            dependents = user_profile.get('user_info', {}).get('dependents', 0)
            dependents_score = max(0, 1 - dependents * 0.2)
            risk_factors.append(('dependents', dependents_score, 0.1))
            
            # Time horizon
            time_horizon = request.time_horizon_years or 10
            time_score = min(1.0, time_horizon / 20)  # 20 years = full score
            risk_factors.append(('time_horizon', time_score, 0.1))
            
            # Calculate weighted risk score
            weighted_score = sum(score * weight for _, score, weight in risk_factors)
            
            # Determine risk category
            if weighted_score >= 0.7:
                risk_category = 'aggressive'
            elif weighted_score >= 0.4:
                risk_category = 'moderate'
            else:
                risk_category = 'conservative'
            
            # Calculate specific risk metrics
            volatility_tolerance = weighted_score
            max_drawdown_tolerance = weighted_score * 0.3  # Max 30% for aggressive
            
            return RiskAssessment(
                risk_score=weighted_score,
                risk_category=risk_category,
                volatility_tolerance=volatility_tolerance,
                max_drawdown_tolerance=max_drawdown_tolerance,
                time_horizon_years=time_horizon,
                risk_factors={factor: score for factor, score, _ in risk_factors},
                recommendations=[
                    f"Based on your {risk_category} risk profile, consider a diversified portfolio",
                    f"Your risk tolerance suggests {int(volatility_tolerance * 100)}% equity allocation",
                    f"Maintain emergency fund of {cushion_months:.1f} months expenses"
                ]
            )
            
        except Exception as e:
            logger.error(f"Error assessing risk profile: {e}")
            return RiskAssessment()
    
    async def _generate_investment_recommendations(
        self, 
        user_profile: Dict[str, Any],
        risk_assessment: RiskAssessment,
        request: FinancialAdvisoryRequest
    ) -> List[InvestmentRecommendation]:
        """Generate personalized investment recommendations"""
        try:
            recommendations = []
            
            # Get market data for analysis
            market_data = await self._get_current_market_data()
            
            # Base allocation based on risk profile
            base_allocation = self.risk_profiles[risk_assessment.risk_category]
            
            # Stock recommendations
            if base_allocation['stocks'] > 0:
                stock_recs = await self._get_stock_recommendations(
                    risk_assessment,
                    base_allocation['stocks'],
                    market_data
                )
                recommendations.extend(stock_recs)
            
            # Bond recommendations
            if base_allocation['bonds'] > 0:
                bond_recs = await self._get_bond_recommendations(
                    risk_assessment,
                    base_allocation['bonds'],
                    market_data
                )
                recommendations.extend(bond_recs)
            
            # Alternative investments
            if risk_assessment.risk_score > 0.6:
                alt_recs = await self._get_alternative_recommendations(
                    risk_assessment,
                    market_data
                )
                recommendations.extend(alt_recs)
            
            # Sort by expected return and risk-adjusted metrics
            recommendations.sort(key=lambda x: x.expected_return, reverse=True)
            
            return recommendations[:10]  # Top 10 recommendations
            
        except Exception as e:
            logger.error(f"Error generating investment recommendations: {e}")
            return []
    
    async def _get_stock_recommendations(
        self, 
        risk_assessment: RiskAssessment,
        allocation_percentage: float,
        market_data: Dict[str, Any]
    ) -> List[InvestmentRecommendation]:
        """Get stock investment recommendations"""
        try:
            recommendations = []
            
            # Broad market ETFs
            broad_market = [
                {
                    'symbol': 'VTI',
                    'name': 'Vanguard Total Stock Market ETF',
                    'category': 'US Total Market',
                    'expense_ratio': 0.03,
                    'expected_return': 0.08,
                    'risk_level': 'moderate'
                },
                {
                    'symbol': 'SPY',
                    'name': 'SPDR S&P 500 ETF',
                    'category': 'Large Cap',
                    'expense_ratio': 0.09,
                    'expected_return': 0.075,
                    'risk_level': 'moderate'
                }
            ]
            
            # Growth vs Value based on risk profile
            if risk_assessment.risk_score > 0.6:
                growth_stocks = [
                    {
                        'symbol': 'QQQ',
                        'name': 'Invesco QQQ Trust',
                        'category': 'Technology Growth',
                        'expense_ratio': 0.20,
                        'expected_return': 0.10,
                        'risk_level': 'high'
                    }
                ]
                broad_market.extend(growth_stocks)
            
            # International exposure
            if allocation_percentage > 0.3:
                international = [
                    {
                        'symbol': 'VEA',
                        'name': 'Vanguard Developed Markets ETF',
                        'category': 'International Developed',
                        'expense_ratio': 0.05,
                        'expected_return': 0.06,
                        'risk_level': 'moderate'
                    }
                ]
                broad_market.extend(international)
            
            # Create recommendations
            for stock in broad_market:
                recommendation = InvestmentRecommendation(
                    symbol=stock['symbol'],
                    name=stock['name'],
                    investment_type='ETF',
                    category=stock['category'],
                    recommended_allocation=allocation_percentage / len(broad_market),
                    expected_return=stock['expected_return'],
                    risk_level=stock['risk_level'],
                    reasoning=f"Diversified exposure to {stock['category']} with low expense ratio",
                    time_horizon=risk_assessment.time_horizon_years,
                    minimum_investment=100,
                    liquidity='High',
                    expense_ratio=stock['expense_ratio']
                )
                recommendations.append(recommendation)
            
            return recommendations
            
        except Exception as e:
            logger.error(f"Error getting stock recommendations: {e}")
            return []
    
    async def _get_bond_recommendations(
        self, 
        risk_assessment: RiskAssessment,
        allocation_percentage: float,
        market_data: Dict[str, Any]
    ) -> List[InvestmentRecommendation]:
        """Get bond investment recommendations"""
        try:
            recommendations = []
            
            bond_options = [
                {
                    'symbol': 'BND',
                    'name': 'Vanguard Total Bond Market ETF',
                    'category': 'Total Bond Market',
                    'expense_ratio': 0.03,
                    'expected_return': 0.03,
                    'risk_level': 'low'
                },
                {
                    'symbol': 'TLT',
                    'name': 'iShares 20+ Year Treasury Bond ETF',
                    'category': 'Long-term Treasury',
                    'expense_ratio': 0.15,
                    'expected_return': 0.025,
                    'risk_level': 'low'
                }
            ]
            
            # High yield bonds for higher risk tolerance
            if risk_assessment.risk_score > 0.5:
                bond_options.append({
                    'symbol': 'HYG',
                    'name': 'iShares iBoxx High Yield Corporate Bond ETF',
                    'category': 'High Yield Corporate',
                    'expense_ratio': 0.49,
                    'expected_return': 0.05,
                    'risk_level': 'medium'
                })
            
            for bond in bond_options:
                recommendation = InvestmentRecommendation(
                    symbol=bond['symbol'],
                    name=bond['name'],
                    investment_type='ETF',
                    category=bond['category'],
                    recommended_allocation=allocation_percentage / len(bond_options),
                    expected_return=bond['expected_return'],
                    risk_level=bond['risk_level'],
                    reasoning=f"Stable income and portfolio diversification through {bond['category']}",
                    time_horizon=risk_assessment.time_horizon_years,
                    minimum_investment=100,
                    liquidity='High',
                    expense_ratio=bond['expense_ratio']
                )
                recommendations.append(recommendation)
            
            return recommendations
            
        except Exception as e:
            logger.error(f"Error getting bond recommendations: {e}")
            return []
    
    async def _get_alternative_recommendations(
        self, 
        risk_assessment: RiskAssessment,
        market_data: Dict[str, Any]
    ) -> List[InvestmentRecommendation]:
        """Get alternative investment recommendations for higher risk tolerance"""
        try:
            recommendations = []
            
            alternatives = [
                {
                    'symbol': 'VNQ',
                    'name': 'Vanguard Real Estate ETF',
                    'category': 'Real Estate',
                    'expense_ratio': 0.12,
                    'expected_return': 0.07,
                    'risk_level': 'medium',
                    'allocation': 0.05
                },
                {
                    'symbol': 'GLD',
                    'name': 'SPDR Gold Shares',
                    'category': 'Commodities',
                    'expense_ratio': 0.40,
                    'expected_return': 0.04,
                    'risk_level': 'medium',
                    'allocation': 0.03
                }
            ]
            
            # Cryptocurrency for very high risk tolerance
            if risk_assessment.risk_score > 0.8:
                alternatives.append({
                    'symbol': 'BTC-USD',
                    'name': 'Bitcoin',
                    'category': 'Cryptocurrency',
                    'expense_ratio': 0.0,
                    'expected_return': 0.15,
                    'risk_level': 'very_high',
                    'allocation': 0.02
                })
            
            for alt in alternatives:
                recommendation = InvestmentRecommendation(
                    symbol=alt['symbol'],
                    name=alt['name'],
                    investment_type='ETF' if alt['symbol'] != 'BTC-USD' else 'Cryptocurrency',
                    category=alt['category'],
                    recommended_allocation=alt['allocation'],
                    expected_return=alt['expected_return'],
                    risk_level=alt['risk_level'],
                    reasoning=f"Portfolio diversification through {alt['category']} exposure",
                    time_horizon=risk_assessment.time_horizon_years,
                    minimum_investment=100,
                    liquidity='Medium' if alt['category'] != 'Cryptocurrency' else 'High',
                    expense_ratio=alt['expense_ratio']
                )
                recommendations.append(recommendation)
            
            return recommendations
            
        except Exception as e:
            logger.error(f"Error getting alternative recommendations: {e}")
            return []
    
    async def _create_portfolio_allocation(
        self, 
        user_profile: Dict[str, Any],
        risk_assessment: RiskAssessment,
        investment_amount: float
    ) -> PortfolioAllocation:
        """Create optimized portfolio allocation"""
        try:
            # Base allocation from risk profile
            base_allocation = self.risk_profiles[risk_assessment.risk_category]
            
            # Adjust based on user specifics
            adjusted_allocation = base_allocation.copy()
            
            # Age-based adjustment (target date approach)
            age = user_profile.get('user_info', {}).get('age', 35)
            stock_percentage = min(0.9, max(0.2, (100 - age) / 100))
            
            # Blend with risk-based allocation
            adjusted_allocation['stocks'] = (adjusted_allocation['stocks'] + stock_percentage) / 2
            adjusted_allocation['bonds'] = 1 - adjusted_allocation['stocks'] - adjusted_allocation['cash']
            
            # Calculate dollar amounts
            stock_amount = investment_amount * adjusted_allocation['stocks']
            bond_amount = investment_amount * adjusted_allocation['bonds']
            cash_amount = investment_amount * adjusted_allocation['cash']
            
            # Expected portfolio metrics
            expected_return = (
                adjusted_allocation['stocks'] * 0.08 +
                adjusted_allocation['bonds'] * 0.03 +
                adjusted_allocation['cash'] * 0.01
            )
            
            expected_volatility = (
                adjusted_allocation['stocks'] * 0.15 +
                adjusted_allocation['bonds'] * 0.05 +
                adjusted_allocation['cash'] * 0.001
            )
            
            return PortfolioAllocation(
                stocks_percentage=adjusted_allocation['stocks'],
                bonds_percentage=adjusted_allocation['bonds'],
                cash_percentage=adjusted_allocation['cash'],
                alternatives_percentage=0.0,
                stocks_amount=stock_amount,
                bonds_amount=bond_amount,
                cash_amount=cash_amount,
                alternatives_amount=0.0,
                expected_annual_return=expected_return,
                expected_volatility=expected_volatility,
                sharpe_ratio=expected_return / max(expected_volatility, 0.01),
                rebalancing_frequency='Quarterly',
                rationale=f"Allocation optimized for {risk_assessment.risk_category} risk profile with {risk_assessment.time_horizon_years}-year horizon"
            )
            
        except Exception as e:
            logger.error(f"Error creating portfolio allocation: {e}")
            return PortfolioAllocation()
    
    async def _analyze_financial_goals(
        self, 
        user_profile: Dict[str, Any],
        financial_goals: List[FinancialGoal]
    ) -> List[Dict[str, Any]]:
        """Analyze and provide guidance on financial goals"""
        try:
            goal_analysis = []
            
            monthly_savings = user_profile.get('monthly_savings', 0)
            
            for goal in financial_goals:
                # Calculate required monthly savings
                months_to_goal = max(1, goal.target_date.year * 12 + goal.target_date.month - 
                                   datetime.now().year * 12 - datetime.now().month)
                
                required_monthly_savings = goal.target_amount / months_to_goal
                
                # Assess feasibility
                feasibility = "High" if required_monthly_savings <= monthly_savings * 0.5 else \
                             "Medium" if required_monthly_savings <= monthly_savings * 0.8 else "Low"
                
                # Calculate with investment growth
                assumed_return = 0.06  # 6% annual return
                monthly_return = assumed_return / 12
                
                if months_to_goal > 12:  # Only consider investment growth for longer-term goals
                    future_value_factor = ((1 + monthly_return) ** months_to_goal - 1) / monthly_return
                    required_monthly_investment = goal.target_amount / future_value_factor
                else:
                    required_monthly_investment = required_monthly_savings
                
                analysis = {
                    'goal': goal,
                    'months_to_goal': months_to_goal,
                    'required_monthly_savings': required_monthly_savings,
                    'required_monthly_investment': required_monthly_investment,
                    'feasibility': feasibility,
                    'recommendations': [
                        f"Save ${required_monthly_investment:.2f} monthly to reach your {goal.goal_type} goal",
                        f"Consider investing in a {'conservative' if months_to_goal < 24 else 'moderate'} portfolio",
                        f"Set up automatic transfers to stay on track"
                    ],
                    'probability_of_success': min(1.0, monthly_savings / max(required_monthly_investment, 1))
                }
                
                goal_analysis.append(analysis)
            
            return goal_analysis
            
        except Exception as e:
            logger.error(f"Error analyzing financial goals: {e}")
            return []
    
    async def _get_market_insights(self) -> List[MarketInsight]:
        """Get current market insights and analysis"""
        try:
            insights = []
            
            # Get market data
            market_data = await self._get_current_market_data()
            
            # Market trend analysis
            sp500_trend = await self._analyze_market_trend('SPY')
            insights.append(MarketInsight(
                category='Market Trend',
                title='S&P 500 Analysis',
                description=f"Current trend: {sp500_trend['trend']}. {sp500_trend['description']}",
                impact='Medium',
                recommendation=sp500_trend['recommendation'],
                confidence=0.75,
                source='Technical Analysis'
            ))
            
            # Interest rate environment
            insights.append(MarketInsight(
                category='Interest Rates',
                title='Current Rate Environment',
                description='Federal Reserve policy impacts bond and stock valuations',
                impact='High',
                recommendation='Consider duration risk in bond portfolios',
                confidence=0.8,
                source='Federal Reserve'
            ))
            
            # Sector rotation insights
            sector_insight = await self._analyze_sector_rotation()
            insights.append(MarketInsight(
                category='Sector Analysis',
                title='Sector Rotation Trends',
                description=sector_insight['description'],
                impact='Medium',
                recommendation=sector_insight['recommendation'],
                confidence=0.7,
                source='Sector Analysis'
            ))
            
            return insights
            
        except Exception as e:
            logger.error(f"Error getting market insights: {e}")
            return []
    
    async def _generate_personalized_advice(
        self, 
        user_profile: Dict[str, Any],
        risk_assessment: RiskAssessment,
        investment_recommendations: List[InvestmentRecommendation],
        goal_analysis: List[Dict[str, Any]]
    ) -> List[PersonalizedAdvice]:
        """Generate personalized financial advice"""
        try:
            advice = []
            
            # Emergency fund advice
            monthly_expenses = user_profile.get('financial_data', {}).get('avg_expense', 0) * 30
            net_worth = user_profile.get('net_worth', 0)
            emergency_months = net_worth / max(monthly_expenses, 1)
            
            if emergency_months < 3:
                advice.append(PersonalizedAdvice(
                    category='Emergency Fund',
                    priority='High',
                    title='Build Emergency Fund',
                    description=f'You currently have {emergency_months:.1f} months of expenses saved. Aim for 3-6 months.',
                    action_items=[
                        'Open a high-yield savings account',
                        f'Save ${monthly_expenses * 3 - net_worth:.2f} for 3-month emergency fund',
                        'Automate monthly transfers to emergency fund'
                    ],
                    expected_benefit='Financial security and peace of mind',
                    timeline='3-6 months'
                ))
            
            # Debt management advice
            total_liabilities = user_profile.get('balance_sheet', {}).get('total_liabilities', 0)
            if total_liabilities > 0:
                advice.append(PersonalizedAdvice(
                    category='Debt Management',
                    priority='High',
                    title='Optimize Debt Repayment',
                    description=f'You have ${total_liabilities:.2f} in liabilities. Consider debt optimization strategies.',
                    action_items=[
                        'List all debts with interest rates',
                        'Consider debt avalanche method (highest interest first)',
                        'Explore refinancing options for lower rates'
                    ],
                    expected_benefit='Reduced interest payments and faster debt freedom',
                    timeline='1-5 years'
                ))
            
            # Investment advice based on risk profile
            if risk_assessment.risk_category == 'conservative':
                advice.append(PersonalizedAdvice(
                    category='Investment Strategy',
                    priority='Medium',
                    title='Conservative Investment Approach',
                    description='Your risk profile suggests a conservative investment strategy focused on capital preservation.',
                    action_items=[
                        'Start with broad market index funds',
                        'Maintain 60-70% bond allocation',
                        'Consider target-date funds for simplicity'
                    ],
                    expected_benefit='Steady growth with lower volatility',
                    timeline='Long-term'
                ))
            elif risk_assessment.risk_category == 'aggressive':
                advice.append(PersonalizedAdvice(
                    category='Investment Strategy',
                    priority='Medium',
                    title='Growth-Oriented Investment Strategy',
                    description='Your risk profile allows for higher growth potential through equity investments.',
                    action_items=[
                        'Increase equity allocation to 70-80%',
                        'Consider growth-oriented ETFs',
                        'Add international diversification'
                    ],
                    expected_benefit='Higher long-term growth potential',
                    timeline='Long-term'
                ))
            
            # Tax optimization advice
            income = user_profile.get('user_info', {}).get('income', 0)
            if income > 50000:
                advice.append(PersonalizedAdvice(
                    category='Tax Optimization',
                    priority='Medium',
                    title='Maximize Tax-Advantaged Accounts',
                    description='Take advantage of tax-deferred and tax-free investment accounts.',
                    action_items=[
                        'Maximize 401(k) contributions, especially with employer match',
                        'Consider Roth IRA for tax-free growth',
                        'Use HSA for triple tax advantage if available'
                    ],
                    expected_benefit='Reduced tax burden and increased savings',
                    timeline='Annual'
                ))
            
            # Goal-specific advice
            for goal_info in goal_analysis:
                if goal_info['feasibility'] == 'Low':
                    advice.append(PersonalizedAdvice(
                        category='Goal Planning',
                        priority='Medium',
                        title=f"Adjust {goal_info['goal'].goal_type} Goal Strategy",
                        description=f"Your current savings rate may not meet your {goal_info['goal'].goal_type} goal timeline.",
                        action_items=[
                            'Consider extending the timeline',
                            'Increase monthly savings rate',
                            'Explore higher-return investment options'
                        ],
                        expected_benefit='Achievable financial goals',
                        timeline=f"{goal_info['months_to_goal']} months"
                    ))
            
            return advice
            
        except Exception as e:
            logger.error(f"Error generating personalized advice: {e}")
            return []
    
    async def _get_current_market_data(self) -> Dict[str, Any]:
        """Get current market data for analysis"""
        try:
            # In a real implementation, this would fetch live market data
            # For now, return mock data
            return {
                'sp500_price': 4500,
                'sp500_change': 0.02,
                'vix': 18.5,
                '10y_treasury': 0.045,
                'dollar_index': 103.2
            }
            
        except Exception as e:
            logger.error(f"Error getting market data: {e}")
            return {}
    
    async def _analyze_market_trend(self, symbol: str) -> Dict[str, str]:
        """Analyze market trend for a given symbol"""
        try:
            # Simplified trend analysis
            # In a real implementation, use technical indicators
            return {
                'trend': 'Bullish',
                'description': 'Market showing upward momentum with strong fundamentals',
                'recommendation': 'Maintain equity allocation with focus on quality companies'
            }
            
        except Exception as e:
            logger.error(f"Error analyzing market trend: {e}")
            return {
                'trend': 'Neutral',
                'description': 'Market trend unclear',
                'recommendation': 'Maintain diversified portfolio'
            }
    
    async def _analyze_sector_rotation(self) -> Dict[str, str]:
        """Analyze sector rotation trends"""
        try:
            return {
                'description': 'Technology and healthcare sectors showing relative strength',
                'recommendation': 'Consider overweighting growth sectors while maintaining diversification'
            }
            
        except Exception as e:
            logger.error(f"Error analyzing sector rotation: {e}")
            return {
                'description': 'Sector trends unclear',
                'recommendation': 'Maintain broad market exposure'
            }
    
    async def _calculate_confidence_score(self, user_profile: Dict[str, Any]) -> float:
        """Calculate confidence score for the advice"""
        try:
            # Factors affecting confidence
            data_completeness = 0.8  # How complete is the user data
            market_stability = 0.7   # Current market conditions
            model_accuracy = 0.85    # Historical model performance
            
            # Calculate weighted confidence
            confidence = (data_completeness * 0.4 + 
                         market_stability * 0.3 + 
                         model_accuracy * 0.3)
            
            return confidence
            
        except Exception as e:
            logger.error(f"Error calculating confidence score: {e}")
            return 0.75  # Default confidence
    
    async def _cache_advice(self, user_id: str, response: FinancialAdvisoryResponse):
        """Cache financial advice in Redis"""
        try:
            redis = await get_redis()
            cache_key = f"financial_advice:{user_id}"
            
            # Cache for 7 days
            await redis.setex(
                cache_key, 
                604800,  # 7 days
                response.json()
            )
            
        except Exception as e:
            logger.warning(f"Failed to cache financial advice: {e}")
    
    async def _load_market_data(self):
        """Load and cache market data"""
        try:
            logger.info("Loading market data...")
            # In a real implementation, load market data from APIs
            
        except Exception as e:
            logger.warning(f"Could not load market data: {e}")
    
    async def cleanup(self):
        """Cleanup resources"""
        try:
            logger.info("Cleaning up Financial Advisory Service...")
            await self.risk_calculator.cleanup()
            await self.portfolio_optimizer.cleanup()
            await self.market_analyzer.cleanup()
            
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")

