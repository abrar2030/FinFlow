#!/bin/bash
# FinFlow Development Workflow Automation
# This script automates cross-service development workflow and service coordination
# Version: 1.0.0

# --- Configuration ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CONFIG_DIR="$PROJECT_ROOT/config"
LOG_DIR="$PROJECT_ROOT/logs"
DEV_DIR="$PROJECT_ROOT/dev"

# --- Colors & Helpers ---
COLOR_RESET="\033[0m"
COLOR_GREEN="\033[32m"
COLOR_RED="\033[31m"
COLOR_YELLOW="\033[33m"
COLOR_BLUE="\033[34m"
COLOR_CYAN="\033[36m"

print_header() {
  echo -e "\n${COLOR_BLUE}==================================================${COLOR_RESET}"
  echo -e "${COLOR_BLUE} $1 ${COLOR_RESET}"
  echo -e "${COLOR_BLUE}==================================================${COLOR_RESET}"
}

print_success() {
  echo -e "${COLOR_GREEN}[SUCCESS] $1${COLOR_RESET}"
}

print_error() {
  echo -e "${COLOR_RED}[ERROR] $1${COLOR_RESET}" >&2
}

print_warning() {
  echo -e "${COLOR_YELLOW}[WARNING] $1${COLOR_RESET}"
}

print_info() {
  echo -e "${COLOR_CYAN}[INFO] $1${COLOR_RESET}"
}

log_message() {
  local level="$1"
  local message="$2"
  local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
  echo "[$timestamp] [$level] $message" >> "$LOG_DIR/dev.log"
}

# --- Command Line Arguments ---
VERBOSE=false
ACTION="start"
SERVICES="all"
HOT_RELOAD=true
DEBUG=false
PORT_OFFSET=0

show_help() {
  echo "Usage: $0 [OPTIONS]"
  echo
  echo "Options:"
  echo "  -h, --help                 Show this help message"
  echo "  -v, --verbose              Enable verbose output"
  echo "  -a, --action ACTION        Action to perform (start, stop, restart, status)"
  echo "  -s, --services SERVICES    Comma-separated list of services to manage (default: all)"
  echo "  --no-hot-reload            Disable hot reloading"
  echo "  --debug                    Enable debug mode"
  echo "  --port-offset OFFSET       Port offset for services (default: 0)"
  echo
  echo "Examples:"
  echo "  $0 --action start"
  echo "  $0 --services auth-service,payments-service"
  echo "  $0 --debug --port-offset 1000"
  exit 0
}

while [[ "$#" -gt 0 ]]; do
  case $1 in
    -h|--help) show_help ;;
    -v|--verbose) VERBOSE=true; shift ;;
    -a|--action) ACTION="$2"; shift 2 ;;
    -s|--services) SERVICES="$2"; shift 2 ;;
    --no-hot-reload) HOT_RELOAD=false; shift ;;
    --debug) DEBUG=true; shift ;;
    --port-offset) PORT_OFFSET="$2"; shift 2 ;;
    *) print_error "Unknown option: $1"; exit 1 ;;
  esac
done

# --- Initialization ---
print_header "FinFlow Development Workflow"
print_info "Starting development workflow with action: $ACTION"

# Create necessary directories
mkdir -p "$LOG_DIR" "$CONFIG_DIR" "$DEV_DIR"

# Initialize log file
echo "=== FinFlow Development Workflow Log $(date) ===" > "$LOG_DIR/dev.log"
log_message "INFO" "Starting development workflow with action: $ACTION"

# --- Load Environment Variables ---
print_header "Loading Environment Variables"

load_env_variables() {
  # Check for .env file
  if [ -f "$PROJECT_ROOT/.env" ]; then
    source "$PROJECT_ROOT/.env"
    print_info "Loaded environment variables from .env"
    log_message "INFO" "Loaded environment variables from .env"
  else
    print_warning "No .env file found. Creating default .env file..."
    log_message "WARNING" "No .env file found. Creating default .env file..."
    
    # Create default .env file
    cat > "$PROJECT_ROOT/.env" << EOL
# FinFlow Development Environment Variables
# Generated by finflow-dev.sh on $(date)
NODE_ENV=development

# Auth Service
AUTH_PORT=$((3001 + $PORT_OFFSET))
JWT_SECRET=dev_secret_key
JWT_EXPIRY=24h

# Payments Service
PAYMENTS_PORT=$((3002 + $PORT_OFFSET))
STRIPE_API_KEY=your_stripe_api_key

# Accounting Service
ACCOUNTING_PORT=$((3003 + $PORT_OFFSET))

# Analytics Service
ANALYTICS_PORT=$((3004 + $PORT_OFFSET))

# Credit Engine
CREDIT_ENGINE_PORT=$((3005 + $PORT_OFFSET))

# Database
POSTGRES_USER=finflow
POSTGRES_PASSWORD=password
POSTGRES_DB=finflow
POSTGRES_HOST=localhost
POSTGRES_PORT=5432

# MongoDB
MONGODB_URI=mongodb://localhost:27017/finflow

# Kafka
KAFKA_BROKER=localhost:9092
KAFKA_ZOOKEEPER=localhost:2181

# Frontend
REACT_APP_API_URL=http://localhost:8080
REACT_APP_AUTH_URL=http://localhost:$((3001 + $PORT_OFFSET))
EOL
    
    print_success "Created default .env file"
    log_message "INFO" "Created default .env file"
    
    source "$PROJECT_ROOT/.env"
  }
  
  # Apply port offset if specified
  if [ "$PORT_OFFSET" -ne 0 ]; then
    print_info "Applying port offset of $PORT_OFFSET to all services"
    log_message "INFO" "Applying port offset of $PORT_OFFSET to all services"
    
    # Update .env file with port offsets
    sed -i "s/AUTH_PORT=\([0-9]\+\)/AUTH_PORT=$((3001 + $PORT_OFFSET))/" "$PROJECT_ROOT/.env"
    sed -i "s/PAYMENTS_PORT=\([0-9]\+\)/PAYMENTS_PORT=$((3002 + $PORT_OFFSET))/" "$PROJECT_ROOT/.env"
    sed -i "s/ACCOUNTING_PORT=\([0-9]\+\)/ACCOUNTING_PORT=$((3003 + $PORT_OFFSET))/" "$PROJECT_ROOT/.env"
    sed -i "s/ANALYTICS_PORT=\([0-9]\+\)/ANALYTICS_PORT=$((3004 + $PORT_OFFSET))/" "$PROJECT_ROOT/.env"
    sed -i "s/CREDIT_ENGINE_PORT=\([0-9]\+\)/CREDIT_ENGINE_PORT=$((3005 + $PORT_OFFSET))/" "$PROJECT_ROOT/.env"
    sed -i "s|REACT_APP_AUTH_URL=http://localhost:\([0-9]\+\)|REACT_APP_AUTH_URL=http://localhost:$((3001 + $PORT_OFFSET))|" "$PROJECT_ROOT/.env"
  }
  
  print_success "Environment variables loaded"
  log_message "INFO" "Environment variables loaded"
}

load_env_variables

# --- Generate Service Dependency Graph ---
print_header "Analyzing Service Dependencies"

generate_dependency_graph() {
  print_info "Generating service dependency graph..."
  log_message "INFO" "Generating service dependency graph"
  
  # Create dependency graph file
  local graph_file="$DEV_DIR/service_dependencies.json"
  
  cat > "$graph_file" << EOL
{
  "auth-service": {
    "dependencies": [],
    "startup_order": 1
  },
  "payments-service": {
    "dependencies": ["auth-service"],
    "startup_order": 2
  },
  "accounting-service": {
    "dependencies": ["auth-service", "payments-service"],
    "startup_order": 3
  },
  "analytics-service": {
    "dependencies": ["auth-service", "accounting-service"],
    "startup_order": 4
  },
  "credit-engine": {
    "dependencies": ["auth-service", "payments-service", "accounting-service"],
    "startup_order": 5
  },
  "web-frontend": {
    "dependencies": ["auth-service", "payments-service", "accounting-service", "analytics-service", "credit-engine"],
    "startup_order": 6
  },
  "mobile-frontend": {
    "dependencies": ["auth-service", "payments-service", "accounting-service", "analytics-service", "credit-engine"],
    "startup_order": 7
  }
}
EOL
  
  print_success "Service dependency graph generated"
  log_message "INFO" "Service dependency graph generated"
}

generate_dependency_graph

# --- Start Services ---
if [ "$ACTION" = "start" ]; then
  print_header "Starting Services"
  
  start_services() {
    print_info "Starting services..."
    log_message "INFO" "Starting services"
    
    # Load dependency graph
    local graph_file="$DEV_DIR/service_dependencies.json"
    if [ ! -f "$graph_file" ]; then
      print_error "Service dependency graph not found"
      log_message "ERROR" "Service dependency graph not found"
      return 1
    fi
    
    # Determine which services to start
    if [ "$SERVICES" = "all" ]; then
      local backend_services=("auth-service" "payments-service" "accounting-service" "analytics-service" "credit-engine")
      local frontend_services=("web-frontend" "mobile-frontend")
    else
      IFS="," read -ra all_services <<< "$SERVICES"
      local backend_services=()
      local frontend_services=()
      
      for service in "${all_services[@]}"; do
        if [[ "$service" == *"frontend"* ]]; then
          frontend_services+=("$service")
        else
          backend_services+=("$service")
        fi
      done
    fi
    
    # Create process ID directory
    mkdir -p "$DEV_DIR/pids"
    
    # Start infrastructure services if needed
    start_infrastructure_services
    
    # Start backend services in dependency order
    for service in $(jq -r 'to_entries | sort_by(.value.startup_order) | .[].key' "$graph_file"); do
      # Skip if service is not in the list of services to start
      if [[ ! " ${backend_services[@]} " =~ " ${service} " ]] && [[ ! " ${frontend_services[@]} " =~ " ${service} " ]]; then
        continue
      fi
      
      # Skip if service is a frontend service (handled separately)
      if [[ "$service" == *"frontend"* ]]; then
        continue
      }
      
      print_info "Starting $service..."
      log_message "INFO" "Starting $service"
      
      local service_dir="$PROJECT_ROOT/backend/$service"
      if [ ! -d "$service_dir" ]; then
        print_warning "Service directory $service not found, skipping"
        log_message "WARNING" "Service directory $service not found, skipping"
        continue
      }
      
      # Check if service is already running
      if [ -f "$DEV_DIR/pids/$service.pid" ]; then
        local pid=$(cat "$DEV_DIR/pids/$service.pid")
        if ps -p "$pid" > /dev/null; then
          print_warning "$service is already running (PID: $pid)"
          log_message "WARNING" "$service is already running (PID: $pid)"
          continue
        else
          rm "$DEV_DIR/pids/$service.pid"
        }
      }
      
      # Install dependencies if needed
      if [ ! -d "$service_dir/node_modules" ]; then
        print_info "Installing dependencies for $service..."
        (cd "$service_dir" && npm install) || {
          print_error "Failed to install dependencies for $service"
          log_message "ERROR" "Failed to install dependencies for $service"
          continue
        }
      }
      
      # Create service log file
      local log_file="$LOG_DIR/${service}.log"
      touch "$log_file"
      
      # Start service
      local start_cmd="npm run"
      if [ "$DEBUG" = true ]; then
        start_cmd="$start_cmd debug"
      elif [ "$HOT_RELOAD" = true ]; then
        start_cmd="$start_cmd start:dev"
      else
        start_cmd="$start_cmd start"
      }
      
      # Copy .env file to service directory
      cp "$PROJECT_ROOT/.env" "$service_dir/.env"
      
      # Start service in background
      (cd "$service_dir" && $start_cmd > "$log_file" 2>&1 & echo $! > "$DEV_DIR/pids/$service.pid")
      
      local pid=$(cat "$DEV_DIR/pids/$service.pid")
      print_success "Started $service (PID: $pid)"
      log_message "INFO" "Started $service (PID: $pid)"
      
      # Wait for service to be ready
      print_info "Waiting for $service to be ready..."
      sleep 5
    }
    
    # Start frontend services
    for service in "${frontend_services[@]}"; do
      print_info "Starting $service..."
      log_message "INFO" "Starting $service"
      
      local service_dir="$PROJECT_ROOT/$service"
      if [ ! -d "$service_dir" ]; then
        print_warning "Service directory $service not found, skipping"
        log_message "WARNING" "Service directory $service not found, skipping"
        continue
      }
      
      # Check if service is already running
      if [ -f "$DEV_DIR/pids/$service.pid" ]; then
        local pid=$(cat "$DEV_DIR/pids/$service.pid")
        if ps -p "$pid" > /dev/null; then
          print_warning "$service is already running (PID: $pid)"
          log_message "WARNING" "$service is already running (PID: $pid)"
          continue
        else
          rm "$DEV_DIR/pids/$service.pid"
        }
      }
      
      # Install dependencies if needed
      if [ ! -d "$service_dir/node_modules" ]; then
        print_info "Installing dependencies for $service..."
        (cd "$service_dir" && npm install) || {
          print_error "Failed to install dependencies for $service"
          log_message "ERROR" "Failed to install dependencies for $service"
          continue
        }
      }
      
      # Create service log file
      local log_file="$LOG_DIR/${service}.log"
      touch "$log_file"
      
      # Copy .env file to service directory
      cp "$PROJECT_ROOT/.env" "$service_dir/.env"
      
      # Start service in background
      (cd "$service_dir" && npm start > "$log_file" 2>&1 & echo $! > "$DEV_DIR/pids/$service.pid")
      
      local pid=$(cat "$DEV_DIR/pids/$service.pid")
      print_success "Started $service (PID: $pid)"
      log_message "INFO" "Started $service (PID: $pid)"
    }
    
    print_success "All services started"
    log_message "INFO" "All services started"
    return 0
  }
  
  start_infrastructure_services() {
    print_info "Starting infrastructure services..."
    log_message "INFO" "Starting infrastructure services"
    
    # Check if Docker is installed and running
    if ! command -v docker &> /dev/null; then
      print_warning "Docker is not installed. Skipping infrastructure services."
      log_message "WARNING" "Docker is not installed. Skipping infrastructure services."
      return 1
    }
    
    if ! docker info &> /dev/null; then
      print_warning "Docker is not running. Skipping infrastructure services."
      log_message "WARNING" "Docker is not running. Skipping infrastructure services."
      return 1
    }
    
    # Check if docker-compose is installed
    if ! command -v docker-compose &> /dev/null; then
      print_warning "Docker Compose is not installed. Skipping infrastructure services."
      log_message "WARNING" "Docker Compose is not installed. Skipping infrastructure services."
      return 1
    }
    
    # Check if infrastructure directory exists
    local infra_dir="$PROJECT_ROOT/infrastructure"
    if [ ! -d "$infra_dir" ]; then
      print_warning "Infrastructure directory not found. Creating it..."
      log_message "WARNING" "Infrastructure directory not found. Creating it..."
      mkdir -p "$infra_dir"
      
      # Create docker-compose.yml file
      cat > "$infra_dir/docker-compose.yml" << EOL
version: '3'

services:
  postgres:
    image: postgres:13
    container_name: finflow-postgres
    ports:
      - "${POSTGRES_PORT}:5432"
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  mongodb:
    image: mongo:4.4
    container_name: finflow-mongodb
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped

  kafka:
    image: wurstmeister/kafka:2.13-2.7.0
    container_name: finflow-kafka
    ports:
      - "9092:9092"
    environment:
      KAFKA_ADVERTISED_HOST_NAME: localhost
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
    depends_on:
      - zookeeper
    restart: unless-stopped

  zookeeper:
    image: wurstmeister/zookeeper:3.4.6
    container_name: finflow-zookeeper
    ports:
      - "2181:2181"
    restart: unless-stopped

volumes:
  postgres_data:
  mongodb_data:
EOL
      
      print_success "Created docker-compose.yml file"
      log_message "INFO" "Created docker-compose.yml file"
    }
    
    # Start infrastructure services
    print_info "Starting infrastructure services with Docker Compose..."
    (cd "$infra_dir" && docker-compose up -d) || {
      print_error "Failed to start infrastructure services"
      log_message "ERROR" "Failed to start infrastructure services"
      return 1
    }
    
    print_success "Infrastructure services started"
    log_message "INFO" "Infrastructure services started"
    return 0
  }
  
  start_services
  start_status=$?
  
  if [ $start_status -ne 0 ]; then
    print_warning "Some services failed to start"
    log_message "WARNING" "Some services failed to start"
  }
}

# --- Stop Services ---
if [ "$ACTION" = "stop" ]; then
  print_header "Stopping Services"
  
  stop_services() {
    print_info "Stopping services..."
    log_message "INFO" "Stopping services"
    
    # Determine which services to stop
    if [ "$SERVICES" = "all" ]; then
      local all_services=("auth-service" "payments-service" "accounting-service" "analytics-service" "credit-engine" "web-frontend" "mobile-frontend")
    else
      IFS="," read -ra all_services <<< "$SERVICES"
    }
    
    # Stop services in reverse order
    for service in $(printf '%s\n' "${all_services[@]}" | tac); do
      print_info "Stopping $service..."
      log_message "INFO" "Stopping $service"
      
      # Check if service is running
      if [ -f "$DEV_DIR/pids/$service.pid" ]; then
        local pid=$(cat "$DEV_DIR/pids/$service.pid")
        if ps -p "$pid" > /dev/null; then
          kill "$pid" || {
            print_warning "Failed to stop $service gracefully, forcing..."
            kill -9 "$pid" || {
              print_error "Failed to force stop $service"
              log_message "ERROR" "Failed to force stop $service"
              continue
            }
          }
          print_success "Stopped $service (PID: $pid)"
          log_message "INFO" "Stopped $service (PID: $pid)"
        else
          print_warning "$service is not running"
          log_message "WARNING" "$service is not running"
        }
        rm "$DEV_DIR/pids/$service.pid"
      else
        print_warning "$service is not running"
        log_message "WARNING" "$service is not running"
      }
    }
    
    # Stop infrastructure services if requested
    if [ "$SERVICES" = "all" ]; then
      stop_infrastructure_services
    }
    
    print_success "All services stopped"
    log_message "INFO" "All services stopped"
    return 0
  }
  
  stop_infrastructure_services() {
    print_info "Stopping infrastructure services..."
    log_message "INFO" "Stopping infrastructure services"
    
    # Check if Docker is installed and running
    if ! command -v docker &> /dev/null || ! docker info &> /dev/null; then
      print_warning "Docker is not running. Skipping infrastructure services."
      log_message "WARNING" "Docker is not running. Skipping infrastructure services."
      return 1
    }
    
    # Check if docker-compose is installed
    if ! command -v docker-compose &> /dev/null; then
      print_warning "Docker Compose is not installed. Skipping infrastructure services."
      log_message "WARNING" "Docker Compose is not installed. Skipping infrastructure services."
      return 1
    }
    
    # Check if infrastructure directory exists
    local infra_dir="$PROJECT_ROOT/infrastructure"
    if [ ! -d "$infra_dir" ] || [ ! -f "$infra_dir/docker-compose.yml" ]; then
      print_warning "Infrastructure directory or docker-compose.yml not found"
      log_message "WARNING" "Infrastructure directory or docker-compose.yml not found"
      return 1
    }
    
    # Stop infrastructure services
    print_info "Stopping infrastructure services with Docker Compose..."
    (cd "$infra_dir" && docker-compose down) || {
      print_error "Failed to stop infrastructure services"
      log_message "ERROR" "Failed to stop infrastructure services"
      return 1
    }
    
    print_success "Infrastructure services stopped"
    log_message "INFO" "Infrastructure services stopped"
    return 0
  }
  
  stop_services
  stop_status=$?
  
  if [ $stop_status -ne 0 ]; then
    print_warning "Some services failed to stop"
    log_message "WARNING" "Some services failed to stop"
  }
}

# --- Restart Services ---
if [ "$ACTION" = "restart" ]; then
  print_header "Restarting Services"
  
  restart_services() {
    print_info "Restarting services..."
    log_message "INFO" "Restarting services"
    
    # Stop services
    ACTION="stop" stop_services
    
    # Start services
    ACTION="start" start_services
    
    print_success "All services restarted"
    log_message "INFO" "All services restarted"
    return 0
  }
  
  restart_services
  restart_status=$?
  
  if [ $restart_status -ne 0 ]; then
    print_warning "Some services failed to restart"
    log_message "WARNING" "Some services failed to restart"
  }
}

# --- Check Service Status ---
if [ "$ACTION" = "status" ]; then
  print_header "Service Status"
  
  check_service_status() {
    print_info "Checking service status..."
    log_message "INFO" "Checking service status"
    
    # Determine which services to check
    if [ "$SERVICES" = "all" ]; then
      local backend_services=("auth-service" "payments-service" "accounting-service" "analytics-service" "credit-engine")
      local frontend_services=("web-frontend" "mobile-frontend")
    else
      IFS="," read -ra all_services <<< "$SERVICES"
      local backend_services=()
      local frontend_services=()
      
      for service in "${all_services[@]}"; do
        if [[ "$service" == *"frontend"* ]]; then
          frontend_services+=("$service")
        else
          backend_services+=("$service")
        }
      }
    }
    
    # Check backend services
    echo -e "\n${COLOR_CYAN}Backend Services:${COLOR_RESET}"
    printf "%-20s %-10s %-10s %-20s\n" "Service" "Status" "PID" "Port"
    printf "%-20s %-10s %-10s %-20s\n" "-------" "------" "---" "----"
    
    for service in "${backend_services[@]}"; do
      local status="STOPPED"
      local pid="-"
      local port="-"
      
      # Check if service is running
      if [ -f "$DEV_DIR/pids/$service.pid" ]; then
        pid=$(cat "$DEV_DIR/pids/$service.pid")
        if ps -p "$pid" > /dev/null; then
          status="RUNNING"
          
          # Determine port
          case "$service" in
            auth-service)
              port=$AUTH_PORT
              ;;
            payments-service)
              port=$PAYMENTS_PORT
              ;;
            accounting-service)
              port=$ACCOUNTING_PORT
              ;;
            analytics-service)
              port=$ANALYTICS_PORT
              ;;
            credit-engine)
              port=$CREDIT_ENGINE_PORT
              ;;
          esac
        else
          rm "$DEV_DIR/pids/$service.pid"
        }
      }
      
      if [ "$status" = "RUNNING" ]; then
        printf "%-20s ${COLOR_GREEN}%-10s${COLOR_RESET} %-10s %-20s\n" "$service" "$status" "$pid" "$port"
      else
        printf "%-20s ${COLOR_RED}%-10s${COLOR_RESET} %-10s %-20s\n" "$service" "$status" "$pid" "$port"
      }
    }
    
    # Check frontend services
    echo -e "\n${COLOR_CYAN}Frontend Services:${COLOR_RESET}"
    printf "%-20s %-10s %-10s %-20s\n" "Service" "Status" "PID" "Port"
    printf "%-20s %-10s %-10s %-20s\n" "-------" "------" "---" "----"
    
    for service in "${frontend_services[@]}"; do
      local status="STOPPED"
      local pid="-"
      local port="-"
      
      # Check if service is running
      if [ -f "$DEV_DIR/pids/$service.pid" ]; then
        pid=$(cat "$DEV_DIR/pids/$service.pid")
        if ps -p "$pid" > /dev/null; then
          status="RUNNING"
          
          # Determine port (frontend typically runs on 3000)
          port="3000"
        else
          rm "$DEV_DIR/pids/$service.pid"
        }
      }
      
      if [ "$status" = "RUNNING" ]; then
        printf "%-20s ${COLOR_GREEN}%-10s${COLOR_RESET} %-10s %-20s\n" "$service" "$status" "$pid" "$port"
      else
        printf "%-20s ${COLOR_RED}%-10s${COLOR_RESET} %-10s %-20s\n" "$service" "$status" "$pid" "$port"
      }
    }
    
    # Check infrastructure services
    echo -e "\n${COLOR_CYAN}Infrastructure Services:${COLOR_RESET}"
    printf "%-20s %-10s %-20s\n" "Service" "Status" "Port"
    printf "%-20s %-10s %-20s\n" "-------" "------" "----"
    
    # Check if Docker is installed and running
    if command -v docker &> /dev/null && docker info &> /dev/null; then
      # Check PostgreSQL
      if docker ps | grep -q "finflow-postgres"; then
        printf "%-20s ${COLOR_GREEN}%-10s${COLOR_RESET} %-20s\n" "PostgreSQL" "RUNNING" "$POSTGRES_PORT"
      else
        printf "%-20s ${COLOR_RED}%-10s${COLOR_RESET} %-20s\n" "PostgreSQL" "STOPPED" "-"
      }
      
      # Check MongoDB
      if docker ps | grep -q "finflow-mongodb"; then
        printf "%-20s ${COLOR_GREEN}%-10s${COLOR_RESET} %-20s\n" "MongoDB" "RUNNING" "27017"
      else
        printf "%-20s ${COLOR_RED}%-10s${COLOR_RESET} %-20s\n" "MongoDB" "STOPPED" "-"
      }
      
      # Check Kafka
      if docker ps | grep -q "finflow-kafka"; then
        printf "%-20s ${COLOR_GREEN}%-10s${COLOR_RESET} %-20s\n" "Kafka" "RUNNING" "9092"
      else
        printf "%-20s ${COLOR_RED}%-10s${COLOR_RESET} %-20s\n" "Kafka" "STOPPED" "-"
      }
      
      # Check Zookeeper
      if docker ps | grep -q "finflow-zookeeper"; then
        printf "%-20s ${COLOR_GREEN}%-10s${COLOR_RESET} %-20s\n" "Zookeeper" "RUNNING" "2181"
      else
        printf "%-20s ${COLOR_RED}%-10s${COLOR_RESET} %-20s\n" "Zookeeper" "STOPPED" "-"
      }
    else
      printf "%-20s ${COLOR_YELLOW}%-10s${COLOR_RESET} %-20s\n" "Docker" "UNAVAILABLE" "-"
    }
    
    print_success "Service status check completed"
    log_message "INFO" "Service status check completed"
    return 0
  }
  
  check_service_status
  status_check_status=$?
  
  if [ $status_check_status -ne 0 ]; then
    print_warning "Service status check completed with warnings"
    log_message "WARNING" "Service status check completed with warnings"
  }
}

# --- Summary ---
print_header "Development Workflow Summary"

print_success "Development workflow action '$ACTION' completed successfully!"
log_message "INFO" "Development workflow action '$ACTION' completed successfully"

if [ "$ACTION" = "start" ]; then
  echo -e "\n${COLOR_GREEN}Services Started:${COLOR_RESET}"
  echo -e "You can check service status with: ${COLOR_CYAN}$0 --action status${COLOR_RESET}"
  echo -e "You can view service logs in: ${COLOR_CYAN}$LOG_DIR${COLOR_RESET}"
  echo -e "You can stop services with: ${COLOR_CYAN}$0 --action stop${COLOR_RESET}"
}

log_message "INFO" "Development workflow summary provided to user"

exit 0
